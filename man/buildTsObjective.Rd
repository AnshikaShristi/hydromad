\name{buildTsObjective}
\alias{buildTsObjective}
\alias{buildObjectiveFun}
\title{
  Generate objective functions with aggregation, transformation and
  a reference model
}
\description{
  Generate objective functions with temporal aggregation, data
  transformation and an optional reference model.
}
\usage{
buildTsObjective(Q, groups = NULL, FUN = sum, ...,
                  ref = NULL, boxcox = FALSE, start = NULL)
}
\arguments{
  \item{Q}{
    observed data, typically a \code{\link{zoo}} object.
  }
  \item{groups}{
    an optional grouping variable, of the same length as \code{Q},
    to aggregate the observed, fitted and reference time
    series. This can be a \code{\link{factor}}, or a plain vector. It
    can also be a \code{zoo} object with \code{factor}-type
    \code{coredata}, in which case it will be matched with corresponding
    times in \code{Q}, etc.
    Typically \code{groups} would be generated by \code{\link{cut.Date}}
    (for regular time periods) or \code{\link{eventseq}} (for
    events). See examples.
  }
  \item{FUN, \dots}{
    the aggregation function (and any extra arguments) to use on each
    group when \code{groups} is specified. The actual aggregation is
    done by \code{\link{eventapply}}. 
  }
  \item{ref}{
    output from a reference model correponding to \code{Q}. This is
    passed, after any aggregation and/or transformation, to
    \code{\link{nseStat}}. If left as \code{NULL}, the mean (of
    aggregated/transformed data) is used.
  }
  \item{boxcox, start}{
    if \code{boxcox = TRUE}, each dataset will be transformed with a
    Box-Cox transformation (see \code{\link{box.cox}}). The power is
    estimated from the observed series \code{Q} (after any aggregation)
    by \code{\link{box.cox.powers}}. Alternatively the power can be
    specified as the value of the \code{boxcox} argument. 
    Note that \code{boxcox = 0} is a log transform. The offset is
    specified as the \code{start} argument; if \code{NULL} it defaults
    to the 10 percentile (i.e. lowest decile) of the non-zero values of
    \code{Q}. 
  }
}
\value{
  \code{buildTsObjective} returns a \code{function}, which can be
  passed arguments \code{Q, X, ...} (the standard signature for hydromad
  objective functions). The \code{Q} argument is ignored since it was
  already specified directly to \code{buildTsObjective}: i.e. the
  returned function is only valid on the same dataset \code{Q} with
  corresponding fitted values \code{X}. Further arguments to the
  returned function will be passed on to \code{\link{nseStat}}
  (therefore the objective function is to be maximised, not minimised).
  If \code{boxcox = TRUE} was specified, the estimated Box-Cox power can
  be extracted from the returned function \code{f} by
  \code{environment(f)$lambda} and similarly for the offset value
  \code{start}. 
}
\author{
  Felix Andrews \email{felix@nfrac.org}
}
\seealso{
  \code{\link{nseStat}},
  \code{\link{eventseq}},
  \code{\link{cut.Date}},
  \code{\link{hydromad.stats}}
}
\examples{
data(Cotter)
dat <- window(Cotter, start = "1990-01-01", end = "1993-01-01")

## use Box-Cox transform with parameters estimated from Q
objfun <- buildTsObjective(dat$Q, boxcox = TRUE)
objfun(X = dat$Q + 10)
## extract the estimated Box-Cox parameters
lambda <- environment(objfun)$lambda
start <- environment(objfun)$start
qqmath(~ box.cox(dat$Q, lambda, start))
## in this case the result is the same as:
nseStat(box.cox(dat$Q,      lambda, start),
        box.cox(dat$Q + 10, lambda, start))

## use monthly aggregation and log transform (Box-Cox lambda = 0)
objfun <- buildTsObjective(dat$Q, groups = cut(time(dat), "months"),
                           FUN = sum, boxcox = 0)
objfun(X = dat$Q + 10)

}
\keyword{ utilities }
\keyword{ optimization }
