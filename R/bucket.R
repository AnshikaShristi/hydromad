## hydromad: Hydrological Modelling and Analysis of Data
##
## Copyright (c) Felix Andrews <felix@nfrac.org>
##

#' Bucket-type Soil Moisture Accounting models.
#' 
#' From Farmer et al 2003, Water Resources Research.
#' The general mass balance structure is:
#' \deqn{dS/dt = p - q(S) - e(S, Ep)}
#'
#' This functions uses the slightly modified forms given in
#' Bai et al 2009, Environmental Modelling and Software.
#' 
#' @aliases bucket.sim bucket
#' @param DATA time-series-like object with columns P (precipitation,
#'   mm) and E (potential evapo-transpiration, mm). 
#' @param Sb Maximum soil water storage (mm).
#' @param fc Field capacity (0 - 1).
#' @param a.ei Interception coefficient (\eqn{\alpha_{ei}}). 
#' @param M Fraction of catchment area covered by deep rooted vegetation.
#' @param a.ss Recession coefficients for subsurface flow from
#'   saturated zone (\eqn{\alpha_{ss}}). 
#' @param S_0 Initial soil moisture level (mm).
#' @param return_state to return the series U, S and ET (evapotranspiration). 
#' @return the simulated effective rainfall, a time series of the same
#'   length as the input series. 
#' @keywords models
#' @export
bucket.sim <-
    function(DATA,
             Sb, fc = 1, a.ei = 0, M = 0, a.ss = 0, S_0 = 0,
             return_state = FALSE)
{
    ## get data into the right form
    DATA <- as.ts(DATA)
    stopifnot(c("P","E") %in% colnames(DATA))
    ## check values
    stopifnot(Sb >= 0)
    stopifnot(S_0 >= 0)
    stopifnot(0 <= fc && fc <= 1)
    stopifnot(0 <= a.ei && a.ei <= 1)
    stopifnot(0 <= M && M <= 1)
    stopifnot(0 <= a.ss && a.ss <= 1)

    ## fc is expressed as a proportion of Sb
    Sfc <- fc * Sb

    P <- DATA[,"P"]
    E <- DATA[,"E"]
    ## skip over missing values (maintaining the state S)
    bad <- is.na(P) | is.na(E)
    P[bad] <- 0
    E[bad] <- 0
    ## TODO: return state from C code
    COMPILED <- (hydromad.getOption("pure.R.code") == FALSE)
    if (FALSE && COMPILED && !return_state) {
        U <- .C(NA, #sma_bucket, TODO
                as.double(P),
                as.double(E),
                as.integer(NROW(DATA)),
                as.double(Sb),
                as.double(fc),
                as.double(a.ei),
                as.double(M),
                as.double(a.ss),
                as.double(S_0),
                U = double(NROW(DATA)),
                NAOK=FALSE, DUP=FALSE, PACKAGE="hydromad")$U
        ## make it a time series object again
        mostattributes(U) <- attributes(DATA)
        class(U) <- "ts"
    } else {
        ## implementation in R for cross-checking (slow)
        U <- S <- ET <- P
        S_prev <- S_0
        for (t in seq(1, length(P))) {
            ## evapo-transpiration
            Eintc <- a.ei * P[t]
            S[t] <- min(Sb, S_prev + P[t] - Eintc)
            Etrans <- M * min(1, S[t] / Sfc) * E[t]
            Ebare <- (1 - M) * (S[t] / Sb) * E[t]
            ET[t] <- Eintc + Etrans + Ebare
            ## mass balance
            S[t] <- S_prev + P[t] - ET[t]
            ## drainage (saturation excess)
            Use <- max(0, S[t] - Sb)
            S[t] <- S[t] - Use
            ## drainage (sub-surface)
            Uss <- a.ss * max(0, S[t] - Sfc)
            S[t] <- S[t] - Uss
            U[t] <- Use + Uss
            S_prev <- S[t]
        }
    }
    ## re-insert missing values
    U[bad] <- NA
    if (return_state) return(ts.union(U=U, S=S, ET=ET))
    return(U)
}

bucket.ranges <- function()
    list(Sb = c(0, 1200),
         fc = c(0, 1),
         a.ei = c(0, 0.49),
         M = c(0, 1),
         a.ss = c(0, 0.5))
