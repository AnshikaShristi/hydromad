

# replace as.object with predictAsObject

# ensure proper use of abToTauV, tauVToAB

# fix up "testing" to use new functions!

# finish docs
# and write examples
# get permission to distribute sample datasets
# write vignette(s) based on analysing sample datasets

# convert ts to zoo in plots etc -- set index class
# "Date" "yearmon" "POSIXct" "numeric"
# default: Date, or
# if (deltat(x) >= 300) POSIXct # (min step 5 minutes)

# cut modelled flow at 1 order of magnitude below lowest observed non-zero flow
# -- in xferfun.sim?
# or: just round to x digits?

# plots for ihacres model objects
#  - overlay ts plot or residuals
#    = transformed: log / sqrt / cumsum(scale(x)
#    = smoothed / aggregated
#    = residuals - cumsum (error mass curve)
#    = rfs
#  - FDC, normal / unif [[ qqmath ]] (ecdf? qqplot?)
#  - qqnorm of residuals? monthplot? cpgram?

# xyplot.ihacres:
#   auto.key does not pick up series names or colours
#   reclass index to Date etc?

# TODO: xferfun.fit catches and hides all errors from ls/sriv -- bad (e.g. NA)

# TODO: handle NAs in effective rainfall functions (na.pass...)

# TODO: testing with NAs in data
# TODO: testing with ts frequency
# TODO: testing with non-daily data (units of hours / minutes? - back to zoo?)
# TODO: write tests in example sections

# code review: with(x, {}) has its own scope

# estimate API `scale` from gain of UH, rather than mass balance?
# allow optimisation of API `scale`?

## what does the loss model calibration surface look like? (smooth?)
## -- is BFGS good enough?
## try multiple starting points (( ihacres_*.fit with each of ihacres_*.run ))

# arguments Xs_0 Xq_0 for xferfun!

# xferfun.fit:
	# estimate initial value for Qs_0 from Q
	# choose order based on objective function / convergence
	# choose delay based on objective function / convergence
	# try prefilter based on ar()? -- does prefilter influence result or just convergence?
	# implement xferfun.arimafit (with prefilter)

# TODO: use lhs package

# TODO: use dtw (dynamic time warping) for variable delays?
#     ::: or just rollapply(estimateDelay)

# residuals(ar()) for performance assessment?

# TODO: updateSelf() rather than predict(as.object=TRUE)? (for changed params)

# allow custom drainage and ET functions for CMD (need to integrate)

# baseflow filtering?

# use dlm / Norton ltv?

